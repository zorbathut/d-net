
#include <cstdio>
#include <fstream>
#include <vector>
#include <iterator>

#include "debug.h"

using namespace std;

void printTemplateTypes(FILE *funcfile, int count, bool typename_token, bool notfirst) {
  for(int j = 0; j < count; j++) {
    if(j || notfirst)
      fprintf(funcfile, ", ");
    if(typename_token)
      fprintf(funcfile, "typename ");
    fprintf(funcfile, "T%d", j);
  }
}

void printParams(FILE *funcfile, int count, bool type, bool name) {
  CHECK(type || name);
  for(int j = 0; j < count; j++) {
    if(j)
      fprintf(funcfile, ", ");
    if(type)
      fprintf(funcfile, "T%d", j);
    if(type && name)
      fprintf(funcfile, " ", j);
    if(name)
      fprintf(funcfile, "param%d", j);
  }
}

int main() {
  dprintf("Generating functor.h");
  
  vector<char> source;
  {
    ifstream sourcefile("functor.h.in");
    CHECK(sourcefile);
    sourcefile >> noskipws;
    copy(istream_iterator<char>(sourcefile), istream_iterator<char>(), back_inserter(source));
  }
  
  FILE *funcfile = fopen("functor.h", "w");
  
  fprintf(funcfile,
    "#ifndef DNET_FUNCTOR\n"
    "#define DNET_FUNCTOR\n"
    "\n"
    "// Generated by functor_gen.cpp. Do not modify this file directly!\n"
    "\n"
    "#include \"smartptr.h\"\n"
    "\n"
    "#include <boost/noncopyable.hpp>\n"
    "\n"
  );
  
  for(int i = 0; i <= 1; i++) {
    int curofs = 0;
    while(curofs != source.size()) {
      if(source[curofs] == '%') {
        CHECK(source[curofs + 1] == '%');
        curofs += 2;
        int endtoken = find(source.begin() + curofs, source.end(), '%') - source.begin();
        CHECK(source[endtoken] == '%' && source[endtoken + 1] == '%');
        string inttoken = string(source.begin() + curofs, source.begin() + endtoken);
        
        if(inttoken == "DEPTH") {
          fprintf(funcfile, "%d", i);
        } else if(inttoken == "TEMPLATE_TOKEN") {
          if(i) {
            fprintf(funcfile, "template <");
            printTemplateTypes(funcfile, i, true, false);
            fprintf(funcfile, "> ");
          }
        } else if(inttoken == "TEMPLATE_TYPES") {
          printTemplateTypes(funcfile, i, true, true);
        } else if(inttoken == "TEMPLATE_TYPES_NOTYPENAME") {
          printTemplateTypes(funcfile, i, false, true);
        } else if(inttoken == "USE_TEMPLATE_TYPES") {
          if(i) {
            fprintf(funcfile, "<");
            printTemplateTypes(funcfile, i, false, false);
            fprintf(funcfile, "> ");
          }
        } else if(inttoken == "PARAMS") {
          printParams(funcfile, i, true, true);
        } else if(inttoken == "PARAMS_NOIDENT") {
          printParams(funcfile, i, true, false);
        } else if(inttoken == "PARAMS_NOTYPE") {
          printParams(funcfile, i, false, true);
        } else {
          dprintf("Intercepted token is %s\n", inttoken.c_str());
        }
        
        curofs = endtoken + 2;
      } else {
        int npos = find(source.begin() + curofs, source.end(), '%') - source.begin();
        fprintf(funcfile, "%s", string(source.begin() + curofs, source.begin() + npos).c_str());
        curofs = npos;
      }
    }
  }
  
  fprintf(funcfile, "\n");
  fprintf(funcfile, "#endif\n");
  
  fclose(funcfile);
}
